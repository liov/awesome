# 这篇讲的能懂
IEEE754规定：

单精度浮点数字长32位，尾数长度23，指数长度8,指数偏移量127；双精度浮点数字长64位，尾数长度52，指数长度11，指数偏移量1023；
约定小数点左边隐含有一位，通常这位数是1，所以上述单精度尾数长度实际为24(默认省略小数点左边的1则为23)，双精度尾数长度实际为53（默认省略小数点左边的1则问53）；
下面讲述使用IEEE754标准表示浮点数：
176.0625表示为单精度浮点数：
解：
1）.先将176.0625转换为二进制数

小数点前:176 / 2 = 88  余数为 0
88 / 2=44 余数为 0                             
44 / 2 =22 余数为 0                       
22 / 2= 11 余数为 0                              
11 / 2 =5   余数为 1        
5 / 2=2 余数为 1                             
2/ 2  =1 余数为 0                                                                             
1/ 2=0        余数为 1    商为0，结束。                                                                       
小数点前整数转换为二进制:10110000                                          

   小数点后：小数部分乘以2，取整数部分，直至乘积小数部分为0   
0.0625 * 2 = 0.125   整数为0                 
0.125 * 2 = 0.25     整数为0             
0.25* 2 = 0.50       整数为0             
0.5* 2 = 1.0 整数为1，小数部分为0,结束

小数点后的小数位转换为二进制：0001

      故176.0625转换为二进制为：10110000.0001

2）.IEEE754约定小数点左边隐含有一位，通常这位数是1，所以10110000.0001=1.01100000001 *  2^7(小数点向左偏移7位);

IEEE754约定单精度指数偏移量为127，所以176.0625使用IEEE754标准表示时，指数偏移量为 7+127=134 ,即:10000110

IEEE754约定单精度尾数长度为23，所以176.0625使用IEEE754标准表示时，尾数为：01100000001000000000000

176.0625>0,即为整数，所以符号位为0

3)由上得出：176.0625使用IEEE754规格化后的表示为：0  10000110 01100000001000000000000

出处：https://blog.csdn.net/dingzhenli1993/article/details/54017921


# 补充：
    这样就能搞懂，js最大精确整数2^53的指数位应该是52+1023（10000110101）1000000 0101
    1	0 01111111 000 0000 0000 0000 0000 0000	1.0
   -1	1 01111111 000 0000 0000 0000 0000 0000	−1.0
   所以js的最大整数不是2^53次方
# 附：
一个浮点数 (Value) 的表示其实可以这样表示：

也就是浮点数的实际值，等于符号位（sign bit）乘以指数偏移值(exponent bias)再乘以分数值(fraction)。
以下内文是IEEE 754对浮点数格式的描述。
本文表示比特的约定
把W个比特（bit）的数据，从内存地址低端到高端，以0到W−1编码。通常将内存地址低端的比特写在最右边，称作最低有效位（Least Significant Bit,LSB），代表最小的比特，改变时对整体数值影响最小的比特。声明这一点的必要性在于X86体系架构是小端序的数据存储。
对于十进制整数N，必要时表示为N10以与二进制的数的表示N2相区分。
对于一个数，其二进制科学计数法表示下的指数的值，下文称之为指数的实际值；而根据IEEE 754标准对指数部分的编码的值，称之为浮点数表示法指数域的编码值。
整体呈现
图1
图1
指数偏差
指数偏差（表示法中的指数为实际指数减掉某个值）为 ，其中的e为存储指数的比特的长度。减掉一个值因为指数必须是有号数才能表达很大或很小的数值，但是有号数通常的表示法——补码（two's complement），将会使比较变得困难。为了解决这个问题，指数在存储之前需要做偏差修正，将它的值调整到一个无符号数的范围内以便进行比较。此外，指数采用这种方法表示的优点还在于使得浮点数的正规形式和非正规形式之间有了一个平滑的转变。指数偏差
图2
图2
指数偏移值
指数偏移值（exponent bias），是指浮点数表示法中的指数域的编码值为指数的实际值加上某个固定的值，IEEE 754标准规定该固定值为 ，其中的 为存储指数的比特的长度。
以单精度浮点数为例，它的指数域是8个比特，固定偏移值是 。此为有号数的表示方式，单精度浮点数的指数部分实际取值是从-127到+128。例如指数实际值为 ，在单精度浮点数中的指数域编码值为 ，即 。
采用指数的实际值加上固定的偏移值的办法表示浮点数的指数，好处是可以用长度为 个比特的无符号整数来表示所有的指数取值，这使得两个浮点数的指数大小的比较更为容易，实际上可以按照字典序比较两个浮点表示的大小。
这种移码表示的指数部分，中文称作阶码。
规约形式的浮点数
如果浮点数中指数部分的编码值在 之间，且在科学表示法的表示方式下，分数 (fraction) 部分最高有效位（即整数字）是1，那么这个浮点数将被称为规约形式的浮点数。“规约”是指用唯一确定的浮点形式去表示一个值。
由于这种表示下的尾数有一位隐含的二进制有效数字，为了与二进制科学计数法的尾数（mantissa）相区别，IEEE754称之为有效数（significant）。
举例来说，双精度 (64-bit) 的规约形式浮点数在指数偏移值的值域为 (11-bit) 到 ，在分数部分则是 到 (52-bit)。
非规约形式的浮点数
如果浮点数的指数部分的编码值是0，分数部分非零，那么这个浮点数将被称为非规约形式的浮点数。一般是某个数字相当接近零时才会使用非规约型式来表示。 IEEE 754标准规定：非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值小1。例如，最小的规约形式的单精度浮点数的指数部分编码值为1，指数的实际值为-126；而非规约的单精度浮点数的指数域编码值为0，对应的指数实际值也是-126而不是-127。实际上非规约形式的浮点数仍然是有效可以使用的，只是它们的绝对值已经小于所有的规约浮点数的绝对值；即所有的非规约浮点数比规约浮点数更接近0。规约浮点数的尾数大于等于1且小于2，而非规约浮点数的尾数小于1且大于0。
除了规约浮点数，IEEE754-1985标准采用非规约浮点数，用来解决填补绝对值意义下最小规格数与零的距离。（举例说，正数下，最大的非规格数等于最小的规格数。而一个浮点数编码中，如果exponent=0，且尾数部分不为零，那么就按照非规约浮点数来解析）非规约浮点数源于70年代末IEEE浮点数标准化专业技术委员会酝酿浮点数二进制标准时，Intel公司对渐进式下溢出（gradual underflow）的力荐。当时十分流行的DECVAX机的浮点数表示采用了突然式下溢出（abrupt underflow）。如果没有渐进式下溢出，那么0与绝对值最小的浮点数之间的距离（gap）将大于相邻的小浮点数之间的距离。例如单精度浮点数的绝对值最小的规约浮点数是 ,它与绝对值次小的规约浮点数之间的距离为 。如果不采用渐进式下溢出，那么绝对值最小的规约浮点数与0的距离是相邻的小浮点数之间距离的 倍！可以说是非常突然的下溢出到0。这种情况的一种糟糕后果是：两个不等的小浮点数X与Y相减，结果将是0.训练有素的数值分析人员可能会适应这种限制情况，但对于普通的程序员就很容易陷入错误了。采用了渐进式下溢出后将不会出现这种情况。例如对于单精度浮点数，指数部分实际最小值是（-126），对应的尾数部分从 , 一直到 相邻两小浮点数之间的距离（gap）都是 ；而与0最近的浮点数（即最小的非规约数）也是 。
特殊值
这里有三个特殊值需要指出：
如果指数是0并且尾数的小数部分是0，这个数±0（和符号位相关）
如果指数= 并且尾数的小数部分是0，这个数是±∞（同样和符号位相关）
如果指数= 并且尾数的小数部分非0，这个数表示为不是一个数（NaN）。
以上规则，总结如下：
形式	指数	小数部分
零	0	0
非规约形式	0	非0
规约形式	1到

任意
无穷	

0
NaN	

非零
32位单精度
单精度二进制小数，使用32个比特存储。
1	8	23位长
S	Exp	Fraction
31	30至23
　　偏正值（实际的指数大小+127）	22至0位编号（从右边开始为0）
S为符号位，Exp为指数字，Fraction为有效数字。 指数部分即使用所谓的偏正值形式表示，偏正值为实际的指数大小与一个固定值（32位的情况是127）的和。采用这种方式表示的目的是简化比较。因为，指数的值可能为正也可能为负，如果采用补码表示的话，全体符号位S和Exp自身的符号位将导致不能简单的进行大小比较。正因为如此，指数部分通常采用一个无符号的正数值存储。单精度的指数部分是−126～+127加上偏移值127，指数值的大小从1～254（0和255是特殊值）。浮点小数计算时，指数值减去偏正值将是实际的指数大小。
单精度浮点数各种极值情况：
类别	正负号	实际指数	有偏移指数	指数域	尾数域	数值
零	0	-127	0	0000 0000	000 0000 0000 0000 0000 0000	0.0
负零	1	-127	0	0000 0000	000 0000 0000 0000 0000 0000	−0.0
1	0	0	127	0111 1111	000 0000 0000 0000 0000 0000	1.0
-1	1	0	127	0111 1111	000 0000 0000 0000 0000 0000	−1.0
最小的非规约数	*	-126	0	0000 0000	000 0000 0000 0000 0000 0001	±2× 2= ±2≈ ±1.4×10
中间大小的非规约数	*	-126	0	0000 0000	100 0000 0000 0000 0000 0000	±2× 2= ±2≈ ±5.88×10
最大的非规约数	*	-126	0	0000 0000	111 1111 1111 1111 1111 1111	±(1−2) × 2≈ ±1.18×10
最小的规约数	*	-126	1	0000 0001	000 0000 0000 0000 0000 0000	±2≈ ±1.18×10
最大的规约数	*	127	254	1111 1110	111 1111 1111 1111 1111 1111	±(2−2) × 2≈ ±3.4×10
正无穷	0	128	255	1111 1111	000 0000 0000 0000 0000 0000	+∞
负无穷	1	128	255	1111 1111	000 0000 0000 0000 0000 0000	−∞
NaN	*	128	255	1111 1111	non zero	NaN
* 符号位可以为0或1.
64位双精度
双精度二进制小数，使用64个比特存储。
1	11	52位长
S	Exp	Fraction
63	62至52
　　偏正值（实际的指数大小+1023）	51至0位编号（从右边开始为0）
S为符号位，Exp为指数字，Fraction为有效数字。指数部分即使用所谓的偏正值形式表示，偏正值为实际的指数大小与一个固定值（64位的情况是1023）的和。采用这种方式表示的目的是简化比较。因为，指数的值可能为正也可能为负，如果采用补码表示的话，全体符号位S和Exp自身的符号位将导致不能简单的进行大小比较。正因为如此，指数部分通常采用一个无符号的正数值存储。双精度的指数部分是−1022～+1023加上1023，指数值的大小从1～2046（0（2进位全为0）和2047（2进位全为1）是特殊值）。浮点小数计算时，指数值减去偏正值将是实际的指数大小。
浮点数的比较
浮点数基本上可以按照符号位、指数域、尾数域的顺序作字典比较。显然，所有正数大于负数；正负号相同时，指数的二进制表示法更大的其浮点数值更大。
浮点数的舍入
任何有效数上的运算结果，通常都存放在较长的寄存器中，当结果被放回浮点格式时，必须将多出来的比特丢弃。 有多种方法可以用来运行舍入作业，实际上IEEE标准列出4种不同的方法：
舍入到最接近：舍入到最接近，在一样接近的情况下偶数优先（Ties To Even，这是默认的舍入方式）：会将结果舍入为最接近且可以表示的值，但是当存在两个数一样接近的时候，则取其中的偶数（在二进制中式以0结尾的）。
朝+∞方向舍入：会将结果朝正无限大的方向舍入。
朝-∞方向舍入：会将结果朝负无限大的方向舍入。
朝0方向舍入：会将结果朝0的方向舍入。
浮点数的运算与函数
标准运算
下述函数必须提供:
加减乘除（Add、subtract、multiply、divide）。在加减运算中负零与零相等：
平方根（Square root）： ，另规定
浮点余数。返回值 。
近似到最近的整数 。如果恰好在两个相邻整数之间，则近似到偶数。
比较运算. -Inf <负的规约浮点数数<负的非规约浮点数< -0.0 = 0.0 <正的非规约浮点数<正的规约浮点数< Inf；
特殊比较： -Inf = -Inf, Inf = Inf, NaN与任何浮点数（包括自身）的比较结果都为假，即 (NaN ≠ x) = false.
精度编辑
在二进制，第一个有效数字必定是“1”，因此这个“1”并不会存储。
讨论一
单精和双精浮点数的有效数字分别是有存储的23和52个位，加上最左手边没有存储的第1个位，即是24和53个位。


由以上的计算，单精和双精浮点数可以保证7位和15位十进制有效数字。
讨论二
C++语言标准定义的浮点数的十进制精度(decimal precision)：十进制数字的位数，可被(浮点数)表示而值不发生变化。C语言标准定义的浮点数的十进制精度为：十进制数字的位数q，使得任何具有q位十进制数字的浮点数可近似表示为b进制的p位数字并且能近似回十进制表示而不改变这q位十进制数字
但由于相对近似误差不均匀，有的7位十进制浮点数不能保证近似转化为32比特浮点再近似转化回7位十进制浮点后保持值不变：例如8.589973e9将变成8.589974e9。这种近似误差不会超过1比特的表示能力，因此(24-1)*std::log10(2)等于6.92，下取整为6，成为std::numeric_limits<float>::digits10以及FLT_DIG的值。std::numeric_limits<float>::max_digits10的值为9，含义是必须9位十进制数字才能区分float的所有值；也即float的最大表示区分度。
类似的，std::numeric_limits<double>::digits10或DBL_DIG是15，
std::numeric_limits<double>::max_digits10是17